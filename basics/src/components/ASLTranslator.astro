<div class="translator-container">
  <div class="translator-card">
    <h1>Speech to ASL Translator</h1>
    
    <div class="input-section">
      <div class="controls">
        <button id="startRecording" class="button primary">
          <span class="icon">üé§</span>
          Start Recording
        </button>
        <button id="stopRecording" class="button secondary" disabled>
          <span class="icon">‚èπ</span>
          Stop Recording
        </button>
      </div>
      
      <div class="transcript-box">
        <h3>Transcript</h3>
        <div id="transcript" class="transcript-content">
          Your speech will appear here...
        </div>
      </div>
    </div>

    <div class="output-section">
      <h3>ASL Translation</h3>
      <div class="asl-display">
        <div id="aslAnimation" class="asl-animation">
          ASL signs will be displayed here...
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .translator-container {
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
  }

  .translator-card {
    background: var(--lw-card-bg);
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    padding: 2rem;
    width: 100%;
    max-width: 800px;
  }

  h1 {
    margin: 0 0 2rem;
    font-size: 2rem;
    font-weight: 600;
    color: var(--lw-text);
    text-align: center;
  }

  h3 {
    margin: 0 0 1rem;
    font-size: 1.2rem;
    font-weight: 500;
    color: var(--lw-text);
  }

  .input-section, .output-section {
    margin-bottom: 2rem;
  }

  .controls {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
  }

  .button {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.5rem;
    border: none;
    border-radius: 6px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .primary {
    background: var(--lw-link);
    color: white;
  }

  .primary:hover:not(:disabled) {
    background: #1557b0;
  }

  .secondary {
    background: #f0f0f0;
    color: var(--lw-text);
  }

  .secondary:hover:not(:disabled) {
    background: #e0e0e0;
  }

  .transcript-box, .asl-display {
    background: #f8f9fa;
    border: 1px solid var(--lw-border);
    border-radius: 6px;
    padding: 1rem;
  }

  .transcript-content {
    min-height: 100px;
    color: #666;
  }

  .asl-animation {
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #666;
  }

  @media (max-width: 768px) {
    .translator-container {
      padding: 1rem;
    }

    .translator-card {
      padding: 1.5rem;
    }

    h1 {
      font-size: 1.5rem;
    }

    .controls {
      flex-direction: column;
    }

    .button {
      width: 100%;
      justify-content: center;
    }
  }
</style>

<script>
  let audioContext: AudioContext | null = null;
  let recorder: Recorder | null = null;
  let gumStream: MediaStream | null = null;

  const startBtn = document.getElementById("startRecording") as HTMLButtonElement;
  const stopBtn = document.getElementById("stopRecording") as HTMLButtonElement;
  const transcriptBox = document.getElementById("transcript") as HTMLDivElement;
  const aslAnimation = document.getElementById("aslAnimation") as HTMLDivElement;

  if (!startBtn || !stopBtn || !transcriptBox || !aslAnimation) {
    console.error("Required elements not found");
  }

  class Recorder {
    private context: AudioContext;
    private node: ScriptProcessorNode;
    private buffer: Float32Array[];
    private recording: boolean;

    constructor(source: MediaStreamAudioSourceNode) {
      this.context = source.context as AudioContext;
      this.node = this.context.createScriptProcessor(4096, 1, 1);
      this.buffer = [];
      this.recording = false;

      this.node.onaudioprocess = (e: AudioProcessingEvent) => {
        if (!this.recording) return;
        this.buffer.push(new Float32Array(e.inputBuffer.getChannelData(0)));
      };
      source.connect(this.node);
      this.node.connect(this.context.destination);
    }

    record(): void {
      this.recording = true;
    }

    stop(): void {
      this.recording = false;
    }

    exportWAV(cb: (blob: Blob) => void): void {
      let flatBuffer = this.flattenArray();
      let wavBlob = this.encodeWAV(flatBuffer);
      cb(wavBlob);
    }

    private flattenArray(): Float32Array {
      let length = 0;
      for (let i = 0; i < this.buffer.length; i++) length += this.buffer[i].length;
      let result = new Float32Array(length);
      let offset = 0;
      for (let i = 0; i < this.buffer.length; i++) {
        result.set(this.buffer[i], offset);
        offset += this.buffer[i].length;
      }
      return result;
    }

    private encodeWAV(samples: Float32Array): Blob {
      const buffer = new ArrayBuffer(44 + samples.length * 2);
      const view = new DataView(buffer);

      this.writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + samples.length * 2, true);
      this.writeString(view, 8, 'WAVE');

      this.writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, this.context.sampleRate, true);
      view.setUint32(28, this.context.sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);

      this.writeString(view, 36, 'data');
      view.setUint32(40, samples.length * 2, true);

      this.floatTo16BitPCM(view, 44, samples);

      return new Blob([view], { type: 'audio/wav' });
    }

    private writeString(view: DataView, offset: number, string: string): void {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    private floatTo16BitPCM(output: DataView, offset: number, input: Float32Array): void {
      for (let i = 0; i < input.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, input[i]));
        s = s < 0 ? s * 0x8000 : s * 0x7FFF;
        output.setInt16(offset, s, true);
      }
    }
  }

  startBtn?.addEventListener('click', async () => {
    try {
      audioContext = new AudioContext();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      gumStream = stream;

      const input = audioContext.createMediaStreamSource(stream);
      recorder = new Recorder(input);
      recorder.record();

      transcriptBox.textContent = "Recording...";
      aslAnimation.textContent = "Waiting for speech...";
      startBtn.disabled = true;
      stopBtn.disabled = false;
    } catch (err) {
      transcriptBox.textContent = "Microphone access denied or error.";
      aslAnimation.textContent = "Error accessing microphone";
      console.error(err);
    }
  });

  stopBtn?.addEventListener('click', () => {
    if (!recorder || !gumStream) return;

    recorder.stop();
    gumStream.getAudioTracks().forEach(track => track.stop());

    transcriptBox.textContent = "Processing audio...";
    aslAnimation.textContent = "Converting to ASL...";
    
    recorder.exportWAV(async (blob) => {
      const formData = new FormData();
      formData.append('file', blob, 'audio.wav');

      try {
        const response = await fetch('https://flaskapispeech2text.onrender.com/transcribe', {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error("Server error:", errorText);
          transcriptBox.textContent = `Server error: ${response.status}`;
          aslAnimation.textContent = "Error processing speech";
          return;
        }

        const data = await response.json();
        transcriptBox.textContent = data.transcription || "No speech detected.";
        
        // Here you would typically process the transcription to ASL
        // For now, we'll just show a placeholder
        aslAnimation.textContent = "ASL translation would appear here";
      } catch (err) {
        transcriptBox.textContent = "Error transcribing speech.";
        aslAnimation.textContent = "Error in translation";
        console.error(err);
      }

      startBtn.disabled = false;
      stopBtn.disabled = true;
    });
  });
</script>